sum = (numbers) => add(*toArray(numbers));
absolute = (n) => n | butIf(n | lt(0), $ negative(n));
isDivisibleBy = (a, b) => a | remainderBy(b) | eq(0);
joinLines = (strings) => (strings | join(on: "\n"));
splitLines = (string) => (string | split(on: "\n"));
isBetween = (n, lower, upper) => (
    n | ge(lower) | and($ n | le(upper))
);
least = (collection, by: = null, default: = null) => (
    byFunction = if(
        by | isNull,
        then: $ itself,
        else: $ by,
    );
    collection
    | running(
        start: if(
            default | isNull,
            then: $ (
                collection | toStream | first
                | ((element) => [byFunction(element), element])
            ),
            else: $ [null, default()],
        ),
        next: (element, state: [leastKey, leastElement]) => (
            key = byFunction(element);
            if(
                leastKey | isNull | or($ leastKey | gt(key)),
                then: $ [key, element],
                else: $ [leastKey, leastElement],
            )
        )
    )
    | last
    @ 2
);
greatest = (collection, by: = null, default: = null) => (
    byFunction = if(
        by | isNull,
        then: $ itself,
        else: $ by,
    );
    collection
    | running(
        start: if(
            default | isNull,
            then: $ (
                collection | toStream | first
                | ((element) => [byFunction(element), element])
            ),
            else: $ [null, default()],
        ),
        next: (element, state: [greatestKey, greatestElement]) => (
            key = byFunction(element);
            if(
                greatestKey | isNull | or($ greatestKey | lt(key)),
                then: $ [key, element],
                else: $ [greatestKey, greatestElement],
            )
        )
    )
    | last
    @ 2
);
toFunction = (value) => if(
    value | isFunction,
    then: $ value,
    else: $ $ value,
);
butIf = (value, condition, ifTrue) => if(
    toFunction(condition)(value),
    then: $ ifTrue(value),
    else: $ value,
);
ifs = (*conditions, else:) => null | switch(*conditions, else:);
swapIf = ([a, b], condition, f) => if(
    toFunction(condition)(a, b),
    then: $ f(b, a),
    else: $ f(a, b),
);
build = (start, next) => (
    streamFrom = (getState) => (
        getStateOnce = callOnce(getState);
        newStream(
            value: getStateOnce,
            next: $ (
                state = getStateOnce();
                streamFrom($ next(state))
            ),
        )
    );
    streamFrom($ start)
);
to = (start, end, by: = 1) => (
    isNoFurtherThan = if(
        by | gt(0),
        then: $ le,
        else: $ ge,
    );
    start
    | build(| add(by))
    | while(| isNoFurtherThan(end))
);
toSize = (start, size, by: = 1) => (
    start | to(start | add(size | down | mul(by)), by:)
);
repeat = (value) => value | build((x) => x);
last = (sequence, default: = null) => sequence | at(-1, default:);
keepLast = (sequence, n) => (
    result = sequence | dropFirst(length(sequence) | sub(n));
    result | butIf(| isString | not, | toArray)
);
dropLast = (sequence, n = 1) => (
    result = sequence | keepFirst(length(sequence) | sub(n));
    result | butIf(| isString | not, | toArray)
);
count = (collection, condition) => collection | where(condition) | toArray | length;
forAll = (collection, condition) => (
    collection
    | count((element) => (element | condition | not))
    | eq(0)
);
forSome = (collection, condition) => (
    collection
    | count(condition)
    | gt(0)
);
reverse = (sequence) => (
    array = sequence | toArray;
    array | length | to(1, by: -1)
    | transform((i) => array @ i)
    | toArray
);
group = (pairs, onGroup: = (x) => x) => (
    result = newMutableMap();
    pairs
    | forEach(([key, value]) => (
        if(
            result.has(key),
            then: $ result.at(key).append(value),
            else: $ result.set(key, newMutableArray([value])),
        )
    ));
    result.entries()
    | transform(([key, value]) => (
        [key, value.elements() | onGroup]
    ))
    | toArray
);
groupBy = (collection, by, onGroup: = (x) => x) => (
    collection
    | transform((element) => [by(element), element])
    | group(onGroup: onGroup)
);
transformArray = (collection, f) => (
    collection
    | transform(f)
    | toArray
);
first = (sequence, default: = null) => sequence | at(1, default:);
transform = (collection, f) => (
    start = collection | toStream;
    streamFrom = (current) => if(
        current.isEmpty(),
        then: emptyStream,
        else: $ newStream(
            value: $ f(current.value()),
            next: $ streamFrom(current.next()),
        )
    );
    streamFrom(start)
);
running = (in, start:, next:) => (
    inStream = in | toStream;
    streamFrom = (current, getState) => (
        getStateOnce = callOnce(getState);
        newStream(
            value: getStateOnce,
            next: $ if(
                current.isEmpty(),
                then: emptyStream,
                else: $ (
                    state = getStateOnce();
                    streamFrom(
                        current.next(),
                        $ next(current.value(), state:)
                    )
                ),
            )
        )
    );
    streamFrom(inStream, $ start)
);
with = (sequence, f) => (
    sequence
    | transform((element) => [f(element), element])
);
withIndex = (sequence) => (
    1 | build(up) | zip(sequence)
);
slice = (sequence, from:, to:) => (
    keeper = if(
        to | ge(0),
        then: $ | keepFirst(to),
        else: $ | dropLast(to | negative | down),
    );
    dropper = if(
        from | ge(0),
        then: $ | dropFirst(from | down),
        else: $ if(
            to | ge(0),
            then: $ | keepLast(from | negative | sub(sequence | length) | add(to)),
            else: $ | keepLast(from | negative | add(to) | up)
        )
    );
    sequence | keeper | dropper
);
while = (sequence, condition) => (
    start = sequence | toStream;
    streamFrom = (current) => if(
        current.isEmpty(),
        then: emptyStream,
        else: $ (
            value = current.value();
            if(
                condition(value),
                then: $ newStream(
                    value: $ value,
                    next: $ streamFrom(current.next()),
                ),
                else: emptyStream,
            )
        )
    );
    streamFrom(start)
);
continueIf = (sequence, condition) => (
    start = sequence | toStream;
    streamFrom = (current) => if(
        current.isEmpty(),
        then: emptyStream,
        else: $ (
            value = current.value();
            newStream(
                value: $ value,
                next: $ if(
                    condition(value),
                    then: $ streamFrom(current.next()),
                    else: emptyStream,
                ),
            )
        )
    );
    streamFrom(start)
);
dropWhile = (sequence, condition) => (
    sequence
    | toStream
    | build((stream) => stream.next())
    | continueIf((stream) => stream.isEmpty() | not | and(
        $ stream.value() | condition
    ))
    | last
);
thenRepeat = (sequence, values) => [sequence, repeat(values)] | flatten;
sliding = (sequence, size) => (
    sequence
    | running(
        start: [null] | repeat | keepFirst(size) | toArray,
        next: (element, state: [first, *rest]) => [*rest, element]
    )
    | dropFirst(size)
);
where = (collection, condition) => (
    collection
    | transform((value) => if(
        condition(value),
        then: $ [value],
        else: $ [],
    ))
    | flatten
);
distinct = (collection) => (
    seen = newMutableSet();
    collection
    | where((value) => (
        seen.has(value) | not | and(
            $ (seen.add(value); true)
        )
    ))
);
zip = (*sequences) => (
    streams = sequences | transform(toStream);
    streamFrom = (currents) => if(
        currents | forSome(|.isEmpty()),
        then: emptyStream,
        else: $ newStream(
            value: $ currents | transform(|.value()) | toArray,
            next: $ streamFrom(currents | transform(|.next())),
        )
    );
    streamFrom(streams)
);
unzip = (sequence, numStreams: = 2) => (
    stream = sequence | toStream;
    streamFrom = (current, i) => if(
        current.isEmpty(),
        then: emptyStream,
        else: $ newStream(
            value: $ current.value() @ i,
            next: $ streamFrom(current.next(), i),
        )
    );
    1 | to(numStreams) | transform((i) => streamFrom(stream, i)) | toArray
);
flatten = (sequence) => (
    outer = toStream(sequence);
    streamFrom = (startOuter, startInner) => (
        [outer, inner] = [startOuter, startInner]
        | build(([outer, inner]) => (
            [outer.next(), outer.value() | toStream]
        ))
        | continueIf(([outer, inner]) => (
            outer.isEmpty() | not | and(
                $ inner.isEmpty()
            )
        ))
        | last;
        if(
            inner.isEmpty(),
            then: emptyStream,
            else: $ newStream(
                value: inner.value,
                next: $ streamFrom(outer, inner.next()),
            )
        )
    );
    streamFrom(outer, emptyStream())
);
transformFlat = (sequence, f) => (
    sequence
    | transform(f)
    | flatten
);
dissect = (sequence, condition) => (
    start = sequence | toStream;
    streamFrom = (start) => if(
        start.isEmpty(),
        then: emptyStream,
        else: $ (
            states = [start.value(), start.next()]
            | build(([element, rest]) => (
                [rest.value(), rest.next()]
            ))
            | continueIf(([element, rest]) => (
                rest.isEmpty() | not | and(
                    $ element | condition | not
                )
            ));
            newStream(
                value: $ states | transform(([element]) => element) | toArray,
                next: $ streamFrom(states | last @ 2)
            )
        )
    );
    streamFrom(start)
);
chunk = (sequence, size) => (
    sequence
    | zip(1 | to(size) | repeat | flatten)
    | dissect(([element, i]) => i | eq(size))
    | transform(| transform(([element]) => element) | toArray)
);
merge = (objects) => (
    objects | transform(properties) | flatten | toObject
);
itself = (x) => x;
cache = (f) => (
    cache = newMutableMap();
    (*posArgs, **namedArgs) => (
        key = [posArgs, namedArgs];
        if(
            cache.has(key),
            then: $ cache.at(key),
            else: $ (
                result = f(*posArgs, **namedArgs);
                cache.set(key, result);
                result
            )
        )
    )
);
also = (value, action) => (action(value); value);
catch = (f) => try(
    f,
    onSuccess: (value) => {status: "success", value:},
    onError: (error) => {status: "error", error:},
);
